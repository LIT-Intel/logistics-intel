import { Router } from "express";
import { z } from "zod";
import { bq } from "../bq.js";

const r = Router();

const Body = z.object({
  q: z.string().trim().max(120).optional(),
  mode: z.enum(["air","ocean"]).optional(),
  hs: z.array(z.string()).optional(),          // optional
  origin: z.array(z.string()).optional(),
  dest: z.array(z.string()).optional(),
  carrier: z.array(z.string()).optional(),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  limit: z.number().int().min(1).max(50).optional(),
  offset: z.number().int().min(0).optional(),
});

r.post("/public/searchCompanies", async (req, res, next) => {
  try {
    const body = Body.parse(req.body ?? {});
    const limit  = body.limit  ?? 25;
    const offset = body.offset ?? 0;

    const where: string[] = ["company_id IS NOT NULL"];
    const params: Record<string, any> = {};
    const types: Record<string, any> = {};

    if (body.startDate && body.endDate) {
      where.push("snapshot_date BETWEEN DATE(@startDate) AND DATE(@endDate)");
      params.startDate = body.startDate;
      params.endDate   = body.endDate;
    } else {
      where.push("snapshot_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 12 MONTH) AND CURRENT_DATE()");
    }

    if (body.q) {
      where.push("LOWER(company_name) LIKE LOWER(CONCAT('%', @q, '%'))");
      params.q = body.q;
    }

    if (body.mode) {
      where.push("UPPER(mode) = UPPER(@mode)");
      params.mode = body.mode;
    }

    // âœ… HS optional; normalize to 4-digit prefixes (handles 4- or 6-digit input transparently)
    if (body.hs?.length) {
      const hs4 = body.hs
        .map(h => (h ?? "").toString().replace(/[^0-9]/g, "").slice(0, 4))
        .filter(h => h.length === 4);
      if (hs4.length) {
        where.push("SUBSTR(hs_code,1,4) IN UNNEST(@hs4)");
        params.hs4 = hs4;
        types.hs4  = { type: "ARRAY", arrayType: { type: "STRING" } };
      }
    }

    if (body.origin?.length) {
      where.push("origin_country IN UNNEST(@origin)");
      params.origin = body.origin;
      types.origin  = { type: "ARRAY", arrayType: { type: "STRING" } };
    }

    if (body.dest?.length) {
      where.push("dest_country IN UNNEST(@dest)");
      params.dest = body.dest;
      types.dest  = { type: "ARRAY", arrayType: { type: "STRING" } };
    }

    if (body.carrier?.length) {
      where.push("carrier IN UNNEST(@carrier)");
      params.carrier = body.carrier;
      types.carrier  = { type: "ARRAY", arrayType: { type: "STRING" } };
    }

    const sql = `
      WITH base AS (
        SELECT
          company_id,
          company_name,
          snapshot_date,
          mode,
          hs_code,
          origin_country,
          dest_country,
          carrier
        FROM \`logistics-intel.lit.shipments_daily_part\`
        WHERE ${where.join(" AND ")}
      ),
      agg AS (
        SELECT
          company_id,
          ANY_VALUE(company_name) AS company_name,
          COUNT(*)           AS shipments,
          MAX(snapshot_date) AS lastShipmentDate,
          ARRAY_AGG(DISTINCT mode IGNORE NULLS) AS modes,
          (SELECT ARRAY_AGG(x ORDER BY x.c DESC LIMIT 5) FROM (
            SELECT hs_code AS v, COUNT(*) c FROM base WHERE hs_code IS NOT NULL GROUP BY v
          ) AS x) AS hsTop,
          (SELECT ARRAY_AGG(x ORDER BY x.c DESC LIMIT 5) FROM (
            SELECT origin_country AS v, COUNT(*) c FROM base WHERE origin_country IS NOT NULL GROUP BY v
          ) AS x) AS originsTop,
          (SELECT ARRAY_AGG(x ORDER BY x.c DESC LIMIT 5) FROM (
            SELECT dest_country AS v, COUNT(*) c FROM base WHERE dest_country IS NOT NULL GROUP BY v
          ) AS x) AS destsTop,
          (SELECT ARRAY_AGG(x ORDER BY x.c DESC LIMIT 5) FROM (
            SELECT carrier AS v, COUNT(*) c FROM base WHERE carrier IS NOT NULL GROUP BY v
          ) AS x) AS carriersTop
        FROM base
        GROUP BY company_id
      ),
      counted AS ( SELECT COUNT(*) AS total FROM agg )
      SELECT
        (SELECT total FROM counted) AS total,
        TO_JSON_STRING(ARRAY(
          SELECT AS STRUCT * FROM agg
          ORDER BY shipments DESC, lastShipmentDate DESC
          LIMIT @limit OFFSET @offset
        )) AS items_json
    `;

    params.limit  = limit;
    params.offset = offset;

    const [rows] = await bq.query({ query: sql, location: "US", params, types });

    const total = Number((rows as any)?.[0]?.total ?? 0);
    const items = (rows as any)?.[0]?.items_json ? JSON.parse((rows as any)[0].items_json) : [];
    res.json({ total, items });
  } catch (err) { next(err); }
});

export default r;
